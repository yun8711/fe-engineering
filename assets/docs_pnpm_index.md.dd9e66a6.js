import{_ as n,v as s,b as e,R as p}from"./chunks/framework.8277b2e6.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/pnpm/index.md","filePath":"docs/pnpm/index.md","lastUpdated":1710305030000}'),a={name:"docs/pnpm/index.md"},o=p(`<h1>Pnpm 概述</h1><p>v8.14.0（2024-02）</p><p><a href="https://pnpm.io" target="_blank" rel="noreferrer">官网</a></p><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>pnpm 是一个用于管理 JavaScript 项目依赖的包管理工具，全称为 &quot;Performant npm&quot;，旨在提供更快速、更高效的依赖管理体验。相较于传统的 npm 和 Yarn，pnpm 采用了一种全新的依赖管理方式，通过共享依赖来减少磁盘占用，同时提供了快速的安装和更新速度。</p><p>核心特点包括：</p><ol><li><strong>快速安装</strong>：采用硬链接和符号链接技术，使得安装依赖时速度更快，相比 npm 速度提升 2 倍以上</li><li><strong>空间共享</strong>：在安装依赖时通过<strong>依赖提升</strong>将相同版本的库共享，从而减少磁盘占用。</li><li><strong>锁定版本</strong>：支持按分支锁定依赖版本，确保在不同开发环境下一致性。</li><li><strong>生态兼容</strong>：兼容现有的 npm 生态，可以无缝使用大部分基于 npm 的包和工具</li><li><strong>支持 monorepo</strong>：内置 monorepo 支持</li><li><strong>安全性</strong>：默认创建非平铺的 node_modules，避免幻影依赖等问题</li></ol><br><h3 id="基于符号链接的依赖管理" tabindex="-1">基于符号链接的依赖管理 <a class="header-anchor" href="#基于符号链接的依赖管理" aria-label="Permalink to &quot;基于符号链接的依赖管理&quot;">​</a></h3><p><strong>npm</strong></p><p>1、在 npm v2 时期，主要是采用简单的<strong>递归依赖</strong>方法，最后形成<strong>高度嵌套的依赖树</strong>。然后就会造成如下问题：<strong>重复依赖嵌套地狱，空间资源浪费，安装速度过慢，文件路径过长</strong>等问题</p><p>2、在 npm v3 时期，采取<strong>扁平化</strong>的依赖结构。这样的依赖结构可以很好的解决重复依赖的嵌套地狱问题，但是却出现<strong>扁平化依赖算法耗时长</strong>这样新的问题</p><p>3、在 npm v5 时，引入 package-lock.json 机制，package-lock.json 的作用是锁定项目的依赖结构，保证依赖的稳定性，有兴趣的朋友可以直接查看官方文档</p><br><p><strong>yarn</strong></p><p>yarn 出现时间为 2016 年，此时 npm 处于 v3 时期，当时 yarn 解决的问题基本就是 npm v5 解决的问题，包括使用 yarn.lock 等机制，锁定版本依赖，实现并发网络请求，最大化网络资源利用率，其次还有利用缓存机制，实现了离线模式。</p><p>其实后面很多 npm 都是在学习 yarn 的机制，上面的机制目前 npm 基本也都实现了，就目前而言 npm 和 yarn 其实并没有差异很大</p><br><p><strong>pnpm</strong></p><p>pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，这样可以做到不会出现重复安装，在项目中需要使用到依赖的时候，pnpm 只会安装一次，之后再次使用都会直接<strong>硬链接</strong>指向该依赖，极大节省磁盘空间，并且加快安装速度</p><blockquote><p><strong>硬链接</strong>：是一个文件的别名，它和原始文件共享相同的索引节点（inode）。这意味着硬链接和它所链接的原始文件在文件系统中是等价的，它们共享相同的数据和权限。硬链接不能跨越不同的文件系统创建，也不能链接到目录</p><p><strong>符号链接（软链接）</strong>：是一个特殊类型的文件，它包含了指向另一个文件或目录的路径。符号链接可以跨文件系统，也可以链接到目录。如果删除了符号链接所指向的原始文件，符号链接将变为一个指向不存在内容的无效链接。</p></blockquote><br><h3 id="非扁平的-node-modules-目录" tabindex="-1">非扁平的 node_modules 目录 <a class="header-anchor" href="#非扁平的-node-modules-目录" aria-label="Permalink to &quot;非扁平的 node_modules 目录&quot;">​</a></h3><p>使用 npm 或 Yarn 安装依赖项时，所有的包都被提升到模块目录的根目录。 这样就导致了一个问题，源码可以直接访问和修改依赖，而不是作为只读的项目依赖。</p><p>pnpm 使用符号链接将项目的直接依赖项添加到模块目录的根目录中。</p><p>举例：创建一个测试项目，使用 pnpm 安装 express 依赖，安装后的 node_modules 目录结构如下：</p><blockquote><p>小技巧：称号链接（软链接）的目录，就像是快捷方式一样，从图形界面上可以明显看出来有个小箭头符号；如果在编辑器中（以 webstrom 为例），右键目录时，会看到“转到链接目标”的选项。</p></blockquote><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">├── node_modules</span></span>
<span class="line"><span style="color:#babed8;">├── .pnpm</span></span>
<span class="line"><span style="color:#babed8;">│    ├── accepts@1.3.8</span></span>
<span class="line"><span style="color:#babed8;">│    │    ├── node_modules</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    ├── accepts</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── package.json</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── index.js</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    ├── mime-types</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── package.json</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── index.js</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    ├── negotiator</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── lib</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── package.json</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    │		├── index.js</span></span>
<span class="line"><span style="color:#babed8;">│    ├── mime-types@2.1.35</span></span>
<span class="line"><span style="color:#babed8;">│    ├── ...  // 其他依赖</span></span>
<span class="line"><span style="color:#babed8;">│    ├── express@4.18.2</span></span>
<span class="line"><span style="color:#babed8;">│    │    ├── node_modules</span></span>
<span class="line"><span style="color:#babed8;">│    │		│    ├── accepts </span></span>
<span class="line"><span style="color:#babed8;">│    │		│    ├── ...     // 其他依赖</span></span>
<span class="line"><span style="color:#babed8;">├── express@4.18.2</span></span></code></pre></div><p>1、pnpm 首先会将包下载到全局存储中（<code>~/.pnpm-store</code>），这是 pnpm 用来存储所有下载的包的地方，这些包可以被多个项目通过硬链接的形式共享</p><p>2、在项目中 <code>node_modules/.pnpm</code> 目录下，以平铺的形式将所有需要的依赖放在这里</p><p>3、对于重复引用的依赖，以软链接的形式链接到 <code>node_modules/.pnpm</code> 下的硬链接上。以上面的为例：<code>accepts@1.3.8</code>所依赖的 <code>mime-types</code>， 是一个软链接，指向的是<code>node_modules/.pnpm/accepts@1.3.8/node_modules/mime-types</code>。</p><br><h3 id="依赖提升" tabindex="-1">依赖提升 <a class="header-anchor" href="#依赖提升" aria-label="Permalink to &quot;依赖提升&quot;">​</a></h3><p>在 <code>pnpm</code> 中，依赖提升（Dependency Hoisting）是一种优化策略，用于减少项目中的重复依赖。</p><p>在传统的 <code>npm</code> 或 <code>yarn</code> 中，每个包的依赖都会被安装在该包的 <code>node_modules</code> 目录下。这意味着如果多个包依赖同一个版本的某个库，那么这个库的副本会在每个包的 <code>node_modules</code> 目录下都存在一份。这会导致项目的存储空间占用增加，以及安装和更新依赖的时间增长。</p><p>而 <code>pnpm</code> 通过依赖提升来解决这个问题。依赖提升的策略是将一个依赖项从其原始位置提升到一个更高的层级，使得多个包可以共享同一个依赖项的副本。这样，同一个版本的库只需要在项目的 <code>node_modules</code> 目录下存在一份，而不是在每个依赖它的包的 <code>node_modules</code> 目录下都存在一份。</p><p>所有依赖项都会被提升到 <code>node_modules/.pnpm/</code></p><p>但是，<code>pnpm</code> 的依赖提升策略并不是无条件的。只有当所有依赖同一个版本的库的包都可以接受提升后的版本时，这个库才会被提升。这是为了避免版本冲突，确保每个包都能使用到它需要的依赖版本。</p><p>这种策略使得 <code>pnpm</code> 在存储空间和安装时间上都比 <code>npm</code> 和 <code>yarn</code> 更高效。</p>`,39),t=[o];function l(d,c,r,i,m,b){return s(),e("div",null,t)}const y=n(a,[["render",l]]);export{u as __pageData,y as default};
