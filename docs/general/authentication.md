---
outline: deep

---

# 身份认证



基本所有网站都有登录功能，登录之后再次请求依然是登录状态，但 http 是无状态的，那如何实现的这种登录状态的保存呢，下面介绍常见的一些方案。

> HTTP（HyperText Transfer Protocol，超文本传输协议）被称为无状态的，是因为每个请求都是独立的，服务器不会存储关于客户端的任何信息。这意味着每次客户端发送新的请求时，服务器都会将其视为全新的请求，而不是之前请求的继续。 
>
> 这种无状态性有其优点和缺点。
>
> 优点是简化了服务器的设计，因为不需要存储和管理客户端的状态信息。这使得服务器可以更容易地处理大量并发请求，因为每个请求都是独立的。  然而，无状态性也带来了一些问题。例如，如果一个用户在网站上进行了一些操作（如添加商品到购物车），然后再次发送请求（如结账），服务器无法知道这两个请求之间的关系，因为它不保存任何关于用户的状态信息。为了解决这个问题，开发人员通常会使用一些技术（如cookies或sessions）来在客户端或服务器端存储状态信息。

<br/>

## HTTP 基本认证

### 介绍

HTTP协议本身提供了一种服务端对客户端进行用户身份验证的方法。

它的工作原理是，当一个HTTP请求需要认证时，服务器会发送一个401 Unauthorized响应，同时在响应头WWW-Authenticate中包含一个挑战信息，通常是Basic realm="User Visible Realm"。

<br/>

### 基本流程

流程如下图：

![img](../public/general/login_1.webp)

1、客户端向服务端请求需要登录态的数据

2、服务端向客户端返回401 Unauthorized 响应，响应头WWW-Authenticate中包含一个挑战信息，通常是`Basic realm="<用户可访问的域名>"`，要求客户端验证

3、客户端根据返回的 `WWW-Authenticate: Basic realm="qq.com"`，弹出用户名和密码输入框要求用户进行验证。

4、用户输入用户名和密码后，客户端将以`Basic base64encode(username:password)`格式发送给服务端。

5、服务器在接收到这个请求后，会解码Authorization的值，提取出用户名和密码，然后验证这些信息。

6、如果验证成功，服务器会处理请求并返回适当的响应。如果验证失败，服务器会再次发送401 Unauthorized响应。

7、在后续的请求中复用认证信息，直到会话结束。

<br/>

### 优缺点

优点：兼容性好，主流浏览器都支持

缺点：

- 不安全，账号密码是Base64编码，很容易解码，一般搭配 https 使用
- 无法主动注销，除非关闭标签或浏览器



## Cookie + Session

### 介绍

`Cookie` + `Session` 的登录方式是目前最经典的一种登录方式。

Cookie 是服务器发送到客户端一段特殊信息，并保存在客户端的一种技术，后续请求时，会自动附带该信息发送给服务器。

Session 是另一种在服务器端保存状态信息的技术，客户端请求服务端时，服务端会为这次请求创建一个数据结构，这个结构可以通过内存、文件、数据库等方式保存

> 可以翻译为“服务端会话”。在一次“会话”期间的多个请求，可以共享数据。

Cookie + Session 实现登录的方案，就是依赖于这两项技术。

当客户端第一次请求服务器时，服务器会为该客户端创建一个Session，并将Session的ID发送给客户端保存，通常是保存在Cookie中，客户端的后续请求会携带这个Session ID，服务器通过Session ID找到对应的Session，从而获取到保存的状态信息。

<br/>

### 基本流程

1、用户输入用户名和密码，发送到后端进行验证

2、后端验证用户信息是否正确，如果正确则创建一个`Session`，并生成一个唯一的Session ID（通常是随机字符串）

3、服务器将Session ID 通过 http 响应（响应头Set-Cookie字段）返回给前端，客户端会将它保存在 Cookie 中

4、用户的后续请求中，会自动携带 Cookie 中的信息，即Session ID，服务端通过 Session ID 找到对应的 Session，从而获取用户的登录状态

<br/>

### 优缺点

**优点**

- Cookie由客户端管理，支持设定有效期、安全加密、防篡改、请求路径等属性。
- Session由服务端管理，支持有效期，可以存储各类数据。

<br/>

**缺点**

1、安全性问题

最大的问题就是CSRF（跨站请求伪造），由于 `Session ID` 存储在 `Cookie` 中，如果攻击者获取到该 `Cookie` 信息，则可以模拟用户身份进行恶意操作。

解决这个问题的方法：

- 验证 referer：HTTP请求头中的 referer 字段通常包含了发起请求的页面的URL，所以可以被用来检查请求是否来自于合法的源。但是，referer字段可以被修改
- 使用 https：对通信内容进行加密
- 设置 `Cookie` 的 `HttpOnly` 属性为 true：js 将无法访问到 Cookie 里的内容，可以防止 XSS 攻击（跨站脚本攻击）

2、跨域问题

由于 `Cookie` 为了安全因素，做了 domain 限制，即只能在同域名下共享，因此跨域访问时无法访问到对应的 `Cookie` 信息。

如果是 a.xxx.com 和 b.xxx.com 这种还好，只要把 domain 设置为顶级域名 xxx.com 就可以了，那么子级域名不同也能自动带上。

但如果顶级域名也不同就没办法了，这种只能在服务端做下中转，把这俩个域名统一成同一个。

一些其他的跨域解决方案，如 `JSONP、CORS` 等

3、分布式 Session

由于 `Session` 信息存储在服务器端，当系统扩展到多台服务器时，需要采用一些集中式的 `Session` 管理方案，否则会出现 `Session` 不一致或者丢失等问题。

解决方案：

- session 复制：就是通过一种机制在各台机器自动复制 session，并且每次修改都同步下。比如 java 的 spring-session
- 把 session 保存在 redis：每台服务器都去 redis 中查，只要一台服务器登录了，其他的服务器也就能查到 session

4、性能问题

由于 `Session` 信息存储在服务器端，因此每次请求都需要从服务器读取 `Session` 信息，这可能会导致性能问题。

为了解决这个问题，可以采用一些缓存方案来提高访问速度

5、交互问题

一些移动设备和浏览器可能会禁用 `Cookie` 和 `Session` 机制，这会导致无法正常登录

Session 通常会设置过期时间。如果用户长时间没有操作，那么Session就会过期，用户就需要重新登录，会给用户带来不便



## Token 登录

### 概述

Token 登录方案是一种常用的前后端分离技术

Token 又叫令牌，是通过服务端生成的一串字符串（通常包含了用户的身份信息和权限等相关信息），作为客户端请求的一个凭证。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。

<br/>

### 基本流程

1、用户输入用户名和密码，前端将用户提交的信息发送到后端进行验证

2、后端验证用户信息是否正确，如果正确则生成一个 Token

3、后端将 Token 返回给前端，客户端可以保存在`LocalStorage`或者`SessionStorage`等本地存储中

4、每次向后端发送请求时，前端都需要在请求头部携带 Token 信息

5、后端接收到请求后会从 Token 中解析出用户身份信息，并通过权限校验等操作来判断请求是否合法

6、如果校验通过，则返回相应的数据，否则返回错误信息

7、在用户退出时，前端需要删除保存的 Token 信息

<br/>

### 优缺点

**优点**

- 客户端可以用Cookie、LocalStorage等存储，服务端不需要存储
- 安全性高：有签名校验，不是通过自动带的 cookie 来关联服务端的 session 保存的状态，所以没有 CSRF 问题
- 支持移动APP端
- 支持跨域：Token 信息存储在客户端，可以轻松地跨域使用
- 性能好：Token 机制不依赖服务器端的资源，因此在大规模高并发访问时，它具有更好的性能表现
- 支持分布式：因为 Token 不保存在服务端，所以无论哪台服务器，只要能解析出数据就能获取登录状态

<br/>

**缺点**

1、安全性

Token 数据一般是放在 header 里的，并且由客户端存储，所以存在被盗用、伪造、篡改等风险

所以一般 jwt 要搭配 https 协议加密通信，设置 Token 过期时间和加密、数字签名等操作

2、线程安全问题

由于 Token 无状态，因此不支持同步机制，可能存在线程安全问题。例如，当同时有多个请求同时使用相同的 Token 时，可能会导致重复登录等问题。

3、性能

Token 把状态数据都保存在了里面，请求的内容变多了，性能也会差一些，所以不要在 Token 里保存太多数据

4、Token 时效

因为 session 是保存在服务端的，所以可以随时让它失效，而 Token 保存在客户端，无法即时让它失效，在例如踢人、退出登录、改完密码下线这种功能就没法实现。

可以配合 redis 来解决，在 redis 中记录下对应的生效状态，每次都去 redis 中查询 Token 是否可用

5、扩展性问题

由于 Token 信息存储在客户端，因此对于大规模分布式系统而言，如果需要多台服务器之间共享 Token，则需要采用一些集中式的 Token 管理方案。

<br/>

### Token 生成方式

1、随机字符串：可以使用一些随机数生成算法，如 UUID、Snowflake（雪花算法） 等来生成一个随机的字符串作为 Token。由于随机字符串本身就是随机分布的，因此具有很高的安全性。

2、JWT（JSON Web Token）：JWT 是一种基于 JSON 格式的开放标准（RFC 7519），用于在多方之间安全地传输信息。它将用户身份信息和权限等相关信息编码成一个 JSON 对象，并通过数字签名或者加密等方式进行验证和保护。JWT 除了可以用于 Token 登录外，还可以用于 API 认证、单点登录等场景。

3、Hash 值：可以将用户身份信息和时间戳等参数通过某种散列函数计算出一个 Hash 值，并将该 Hash 值作为 Token 返回给客户端。由于 Hash 值具有不可逆性和唯一性，因此也具有较高的安全性。

无论采用哪种方式生成 Token，都需要结合实际业务场景和安全需求来选择，并且需要对 Token 进行加密或者数字签名等操作来保障其安全性。同时，在 Token 的过期时间、密钥管理、Token 注销等方面都需要考虑相应的安全措施。

<br/>

### JWT

> JWT 官网：https://jwt.io/introduction

JWT（`JSON Web Token`）是 `Auth0` 提出的通过 `对JSON进行加密签名` 来实现授权验证的方案，它有三部分组成： 

1、Header头部：

```json
{
   "alg": "Hash算法(HMAC、SHA256或RSA)",
   "typ": "Token的类型(JWT)"
 }
```

2、Payload负载：

```json
{
   "iss": "签发人(issuer)",
   "exp": "过期时间(expiration time)",
   "sub": "主题(subject)",
   "aud": "受众(audience)",
   "nbf": "生效时间(not before)",
   "iat": "签发时间(issued at)",
   "jti": "编号(JWT ID)",
   "uid": "自定义字段(可以存储用户ID等)",
 }
```

3、Signature 签名：

```js
HMACSHA256(
   base64UrlEncode(header) + "." + base64UrlEncode(payload),
   secret //设置的密钥
)
```

生成的 JWT 是一个很长的字符串，中间用点（ `.` ）分隔成三个部分，列如 ：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

<br/>

### Refresh Token

在使用 JWT 登录时，为了避免被盗用，Token一般有效期比较短，但是有效期太短会造成客户端不断重新登录，体验很差，所以就有了 Refresh Token，它是专门用来生成 Token 的 Token。

使用Refresh Token 的流程如下：

![img](../public/general/login_2.webp)

1. 客户端向服务端发送认证信息（例如账号密码）
2. 服务端根据客户端提供的认证信息执行验证逻辑，如果验证成功则生成Token和Refresh Token并返回
3. 客户端存储收到的Token和Refresh Token，再次请求时携带Token（一般是HTTP请求头Authorization字段）
4. 服务端校验Token，并根据业务逻辑返回相应的数据
5. 如果服务端发现Token过期了，拒绝了请求
6. 客户端重新请求并携带Refresh Token
7. 服务端校验Refresh Token并返回新Token和新Refresh Token
8. 客户端再次请求并携带新Token



## SSO 单点登录

### 介绍

SSO（Single Sign-On，单点登录）是一种在多个应用程序（比如 Web 服务）中实现认证和授权的方法。它允许用户只需登录一次，就可以访问多个相互信任的应用程序，大大提高了用户体验和工作效率。

它是目前比较流行的企业业务整合的解决方案之一。

**实现机制**

当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据：**ticket**；用户再访问别的应用的时候就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。

实现SSO 的关键是如何让 `Session Id`（或 `Token`）在多个域中共享。

<br/>

### 基本流程

假如现在有域名`abc.com`和`123.com`要实现互相自动登录，认证服务器为 cas.com。流程如下：

**先访问 `abc.com`**

![img](../public/general/login_3.webp)

1、客户端访问 abc.com

2、abc.com 发现没有登录（abc.com下没有 Session 或失效），返回 302 重定向到 cas.com 并携带 abc.com 的回调地址（用于登录成功再跳转回来的页面链接）

3、cas.com 发现没有登录（cas.com下没有 Session 或失效），返回 302 重定向到 cas.com **登录页**并携带 abc.com 的回调地址

4、客户端携带 abc.com 回调地址访问 cas.com 的登录页面

5、客户端向 cas.com 发送认证信息

6、cas.com 验证认证信息通过并生成 cas.com 域下的 Session，同时生成一个 ticket，根据回调地址携带此 Token 重定向到 abc.com

7、客户端携带 ticket 访问 abc.com

8、abc.com 服务端使用访问 cas.com 验证 ticket 的有效性，验证成功并生成 abc.com 域下的 Session，完成登录

> 此时在完成登录后，客户端有 2 个 Cookie，分别是 abc.com 和 cas.com 的

9、再访问 abc.com 的其他页面时，因为已经存在登录信息，所以可以正常访问

<br/>

**再访问 123.com**

![img](../public/general/login_4.webp)

1、客户端访问 123.com

2、123.com 校验失败，需要登录（123.com 域下没有 Session 或失效），302 重定向到 cas.com，并携带 123.com 回调地址

3、客户端携带 123.com 回调地址访问 cas.com

4、cas.com 根据 cas.com 域下的 ticket（访问 abc.com 时生成的）发现用户已登录，生成 Token 后 302 重定向到 123.com

5、123.com 访问 cas.com 验证 Token 的有效性，验证成功并生成 123.com 域下的 Session，完成登录

<br/>

### 实现方式

**对于同一根域**

一般情况下， Session 信息保存在 Cookie 中，而 Cookie 的作用域由 `domain` 属性和 `path` 属性共同决定，如果将 `Cookie` 的 `domain` 属性设置为当前域的父域，那么父域下的 Cookie 会被所有子域共享

所以这种方式只能在主域名相同时使用，不支持跨主域名

**对于多个根域**

基于认证中心 `CAS（Central Authentication Service）`中央授权服务来提供统一的登录功能。

这种实现方式相对复杂，但**支持跨域，扩展性好，是单点登录的标准做法**。



## OAuth 第三方登录

### 介绍

[OAuth](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FOAuth)（是 Open Authorization 开放授权的缩写）,在全世界得到广泛应用，目前的版本是2.0版

OAuth 2.0 是一个开放标准，用于授权用户访问另一个应用程序的资源，而无需将用户的凭据（比如用户名和密码）直接提供给第三方应用。它被广泛应用于各种网络服务，如社交媒体、云存储和在线支付等领域

举个例子：

比如我们的应用程序想要获取 GitHub 用户的仓库信息，但是 GitHub 不允许外部网站直接读取用户的仓库信息，也就是说需要用户授权给我们的应用程序才能读取到用户的仓库信息。

传统的做法是用户提供他的帐号和密码，然后我们就可以读取信息了，但是是会存在一些问题：

- 我们的应用程序保存了用户的认证信息，但用户没法限制应用程序的授权范围和有效期，非常不安全
- GitHub 不得不部署密码登录，但是单纯的密码登录并不安全
- 用户只有修改密码才能收回授权，但是这样会造成其他的第三方应用程序都失效
- 只要有一个应用程序被破解，用户的认证信息就会被泄漏，所有受密码保护的数据也会泄漏

OAuth 就是为了解决上面这些问题而诞生的。

[一个示例项目](https://github.com/flower0wine/code-example/tree/main/oauth)

<br/>

### 优点

相比于传统的用户名密码登录方式，第三方登录具有以下优势：

- 便捷性：用户可以直接使用其已有的社交账号登录，无需再次注册或填写信息，提高了用户体验。
- 安全性：第三方平台通常会对用户的信息进行加密存储和传输，在一定程度上提高了用户数据的安全性和保密性。
- 防止账号被盗：由于用户不需要在每个应用中输入账号和密码，因此也降低了账号被盗的风险

<br/>

### 基本流程

需要了解几个术语：

- **Authorization server**：授权服务器，验证资源所有者并获得授权。验证成功后向客户端颁发访问令牌的服务器。
- **Resource server**：资源服务器，托管受保护资源的服务器，接收并响应携带访问令牌的资源请求。
- **Resource Owner**：资源所有者，一种能够授予对受保护资源的访问权限的实体
- **Client**：代表发出受保护资源请求的应用程序，比如我们开发的网站就是这里说的应用程序

基本流程如下图，参考[微信登录开发指南](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html)

![img](../public/general/login_5.png)

1、客户端向微信开发平台（资源所有者）发起请求授权，一般是通过授权服务器间接发起，比如 github 登录时，会跳转到一个页面让我们进行授权

2、所有者（用户）确认授权后，客户端接收授权凭证（Authorization Grant）

3、客户端请求携带AppID、AppSecret、Authorization Grant等信息，向授权服务器验证授权码

4、授权服务器如果验证通过，会颁发访问令牌（access_token）和刷新令牌（refresh_token）

5、客户端携带访问令牌向资源服务器请求受保护的资源

6、资源服务器验证访问令牌，如果有效，则为客户端提供服务

7、一般 access_token 有效期较短，当 access_token 超时失效后，可以使用 refresh_token 进行刷新，如果refresh_token 可用，则刷新 access_token，重复步骤 5，如果 refresh_token 也失效，需要重新授权

<br/>

### 授权模式

授权凭证是客户端用来获得访问令牌的关键，`OAuth2.0` 标准定义四种授权模式：

1、授权码模式（Authorization Code）

这种方法是最安全的，也是使用最多的授权方式。

客户端并不直接向资源所有者请求授权，而是被引导到授权服务（在 [RFC2616] 中定义的用户代理），先获取一个授权码，而资源所有者只通过授权服务器进行身份验证，所以资源所有者的凭据永远不会与客户端共享。

授权码提供了一些重要的安全优势，例如对客户端进行身份验证的能力（因为需要先在授权的平台进行注册认证），以及将访问令牌直接传输到客户端，而无需通过资源所有者的用户代理将其传递给其他人，包括资源所有者。

2、隐式授权模式（Implicit）

是针对使用诸如 JavaScript 之类的脚本语言在浏览器中实现的客户端而优化的简化授权代码流程。

授权服务器不再向客户端颁发授权码，而是直接颁发访问令牌。

隐式授权因为减少了获得访问令牌所需的往返次数，所以提高了一些客户端（例如作为浏览器内应用程序实现的客户端）的响应能力和效率。然而，这种便利性应与使用隐式授权的安全影响进行权衡，尤其是当授权码授权类型可用时。

3、密码模式（Resource Owner Password Credentials）

资源所有者的认证凭据（即用户名和密码）可以直接用作获得访问令牌的授权授予。只有当资源所有者和客户端之间存在高度信任时（例如，客户端是设备操作系统或高特权应用程序的一部分），以及当其他授权授予类型不可用时（例如授权码），才可以使用资源所有者密码凭据。

4、客户端模式（Client Credentials）

当授权范围仅限于客户端控制下的受保护资源，或仅限于先前与授权服务器安排的受保护资源时，客户端凭据（或其他形式的客户端身份验证）可用作授权授予。通常，当客户端代表自己行事（客户端也是资源所有者）或根据先前与授权服务器安排的授权请求访问受保护资源时，客户端凭据可用作授权授予。



## 扫码登录

扫码登录是一种快捷方便的登录方式，用户只需要通过扫描二维码即可完成登录操作，无需输入用户名和密码等信息。在网页、APP 等应用中广泛应用，可以提高用户使用体验和安全性。

<br/>

### 优点

- 方便快捷：扫一下二维码即可完成登录，无需输入账号密码等信息，操作简单方便
- 安全性高：相比于传统的用户名和密码方式，扫码登录更加安全，因为扫描过程中不会暴露敏感信息，如密码等
- 体验好：扫码登录无需手动输入任何信息，对于移动设备尤其友好，用户体验更好

<br/>

### 基本流程

![img](../public/general/login_6.png)

1、客户端访问登录页面，前端向后端请求登录的二维码和key（或者是 uuid），这个key用来索引用户登录状态

2、服务端生成二维码，并保存该 key 的值（比如 key=123），然后将二维码和参数返给前端，前端展示一个用来登录的二维码图片

> 这里的二维码其实就是一个登录链接，像：`https://login.weixin.qq.com/l/AfZJf7-ioA==`
>
> 这里可以后端生成二维码图片并上传到OSS，然后返回给前端相应的图片地址；也可以直接返回给前端字符串，前端自己去生成二维码

3、客户端开始轮询登录状态（也可以使用其他的方式代替软询）

4、用户手机扫码后，移动端跳转到授权登录页，携带 key=123 

5、用户在移动端点击登录后，通知服务端该 key=123 对应的用户就是需要授权登录的

6、服务端找到 key=123 对应的信息，更新用户登录状态和用户信息。前端再轮询时，服务端发现状态改变，则返回给前端登录成功，并返回登录的用户信息

7、前端收到登录成功的返回，就更新登录状态，展示用户信息，停止轮询



## 一键登录

### 介绍

也叫“本机号码一键免密登录”，是指用户在移动端应用或网站中，通过验证手机号快速完成登录的方式

这是一种更为“懒人”的验证方式，既不需要用户输入账号密码，也不需要输入手机号来获取短信验证码，接受协议后，直接由运营商帮助APP取号验证，用户可以点击一键登录。

一键登录更加方便快捷，并且可以免除密码管理和找回密码等问题



### 基本流程

![img](../public/general/login_7.png)

1、调用 `SDK` 的初始化方法，传入项目在平台上的 `AppKey` 和 `AppSecret`。

2、发起授权：调用 SDK 唤起授权接口。SDK 会先向运营商发起获取手机号掩码的请求，请求成功后跳转到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。

3、同意授权：用户同意相关协议，点击授权页面的登录按钮，`SDK` 会请求本次取号的 `token`，请求成功后将 `token` 返回给客户端

4、取号：客户端用获取到的 token 发送到自己的服务端，由服务端携带 token 调用运营商一键登录的接口，调用成功就返回手机号。自己的服务端完成登录或注册逻辑，返回结果给客户端，完成登录。

### 注意

在没有插电话卡，或者关闭移动蜂窝网络的情况下，是无法完成一键登录的。所以就算接入了一键登录，我们也要兼容传统的登录方式，允许用户在认证失败的情况下，手动输入手机号登录。
